\section{Discussion \& Limitations}

\PP{Practical Implications for SOC Deployment} Our results indicate that SLMs can support day-to-day NLQ$\rightarrow$KQL authoring when paired with lightweight scaffolding. Zero-shot SLMs provide fast, low-cost drafts but require schema context to avoid table and column hallucinations. Few-shot exemplars further reduce revision effort, and error-aware tips eliminate recurring syntactic mistakes with minimal token overhead. The two-staged architecture is operationally attractive: one Gemma-3-4B-IT generators keep latency bounded, while a low-cost Oracle (Gemini 2.0 Flash) selects and refines a single query under a code-only policy and a validator. For SOCs, this suggests a practical pattern: local or private SLMs for generation, a narrow LLM for judgment and refinement, and strict validation before execution.

\PP{Generalizability to Languages} The framework extends beyond SQL to EQL\cite{Elastic_Query_Language_Documentation} and SPL\cite{Search_Manual} with straightforward changes. We treat EQL indexes/index patterns and SPL index–sourcetype pairs or CIM datamodels as “tables”; build schemas from Elasticsearch mappings (typed fields, keyword variants, ECS when available) or from Splunk knowledge objects and \CodeIn{tstats} introspection; then retrieve top-t sources and top-v fields. Few-shot selection is unchanged; examples are serialized in native syntax (EQL \CodeIn{event}/\CodeIn{sequence} with \CodeIn{where}, \CodeIn{by}, \CodeIn{with maxspan}; SPL \CodeIn{search}, \CodeIn{where}, \CodeIn{stats}, or \CodeIn{tstats} when a datamodel applies). Prompts add guardrails: EQL uses canonical timestamp comparisons and restricts fields to chosen indexes; SPL specifies \CodeIn{earliest}/\CodeIn{latest} in the \CodeIn{search} command, prefers \CodeIn{tstats} for datamodel fields, and avoids \CodeIn{table} or \CodeIn{timechart} unless requested. Validators swap accordingly: EQL uses a dry-run parse plus field-existence and legal \CodeIn{sequence}/\CodeIn{maxspan}/\CodeIn{by} checks; SPL uses the parser with per-stage field checks and \CodeIn{tstats} enforcement. Metrics adapt mechanically: table scores → index or index–sourcetype scores; filter scores = Jaccard over fields/literals in \CodeIn{where} or \CodeIn{stats by}, penalizing out-of-schema fields; EQL sequences must have correct stage order. To manage tokens, we cap context to top-t sources and top-v fields and include only relevant operator cheat sheets (e.g., EQL sequence syntax; SPL \CodeIn{stats}/\CodeIn{tstats}).